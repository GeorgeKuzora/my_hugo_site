---
title: "Дипломная работа - Веб приложение для поиска автосервисов (writing in public)"
subtitle: ""
description: "Дипломная работа пока не завершена. Я обновляю рукопись по мере работы над ней."
date: 2024-02-18T10:53:41+03:00
author: "Георгий Кузора"
image: "img/fog_forest.jpg"
tags: ["python", "django", "linux", "docker"]
categories: ["Tech"]
draft: false
---

## Оглавление

TODO

## Вступление

В современном мире, когда технологии развиваются с невероятной скоростью, многие сферы жизни человека претерпевают кардинальные изменения. Одной из таких сфер является автомобильный транспорт и обслуживание автомобилей. С ростом числа автомобилей на дорогах, увеличивается и потребность в качественных автосервисах, которые могут удовлетворить потребности автовладельцев в ремонте, обслуживании и диагностике.

Актуальность темы данной дипломной работы заключается в том, что создание удобного и эффективного веб-приложения для поиска автосервисов может значительно упростить жизнь автовладельцам, предоставив им доступ к актуальной информации о ближайших автосервисах, их услугах, ценах и отзывах других клиентов. Кроме того, такое приложение может помочь автосервисам увеличить свою клиентскую базу, улучшить качество обслуживания и оптимизировать рабочие процессы.

В ходе работы над бэкенд частью проекта будут использоваться современные технологии, такие как Django, PostgreSQL, Docker, Poetry, REST, Python и другие.

Разработанное веб-приложение для поиска автосервисов будет доступно для использования широкой аудитории автовладельцев, а также сможет стать полезным инструментом для автосервисов в продвижении своих услуг и улучшении качества обслуживания клиентов. Результаты данной дипломной работы могут быть использованы как в коммерческих, так и в некоммерческих целях, способствуя развитию отрасли автосервиса и улучшению качества жизни автовладельцев.

## Описание проекта

### Цель проекта

Целью данной дипломной работы является разработка бэкенд части веб-приложения, которое будет обеспечивать эффективный поиск автосервисов, а также предоставление пользователям подробной информации о каждом автосервисе. Для достижения данной цели необходимо решить следующие задачи:

1. Разработать архитектуру веб-приложения с учетом современных требований и стандартов веб-разработки.
2. Реализовать функционал поиска и фильтрации автосервисов по различным параметрам, таким как местоположение, предоставляемые услуги, стоимость и отзывы клиентов.
3. Обеспечить интеграцию с внешними сервисами для получения актуальной информации об автосервисах и отзывов клиентов.
4. Разработать удобный пользовательский интерфейс, который позволит пользователям быстро и легко находить необходимую информацию.
5. Протестировать разработанное веб-приложение на предмет его эффективности, надежности и удобства использования.
6. Развернуть и запустить полнофункциональное приложение на сервере, объединяющее в себе бэкенд, фронтенд, базу данных и веб-сервер,

По результатам разработки, приложение должно соответствовать требованиям и обладать минимально необходимым набором функций. В этот набор должны входить:

- регистрация пользователя в приложении;
- регистрация представителя автосервиса в приложении;
- возможность изменения личных данных пользователя в его личном кабинете;
- возможность корректировки информации о представителе автосервиса в его личном кабинете;
- отображение списка ближайших автосервисов для пользователя;
- опция отправки запроса на обслуживание в автосервисе;
- просмотр запросов на ремонт представителем автосервиса;
- общение с клиентом через приложение по отправленному запросу;
- смена статуса запроса;
- закрытие запроса с различными статусами.

### Структура проекта

Современные веб-приложения имеют сложную структуру, состоящую из множества компонентов. Одним из популярных подходов к разработке веб-приложений является использование React для фронтенд-части и Django/PostgreSQL для бэкенд-части. В этом случае, фронтенд и бэкенд могут быть расположены в разных репозиториях для удобства разработки и масштабирования.

В таком случае, веб-приложение будет состоять из двух частей: фронтенд на React и бэкенд на Django/PostgreSQL. Обе части будут работать вместе, обмениваясь данными через API.

Для реализации такого подхода, необходимо выполнить следующие шаги:

1. Разработать фронтенд-часть на React. Это включает в себя создание компонентов, которые будут использоваться для отображения данных, и разработку логики работы с API.
2. Разработать бэкенд на Django. Это включает создание моделей для работы с данными, разработку API и создание контроллеров для обработки запросов.
3. Создать базу данных и таблицы для хранения данных.
4. Интегрировать React и Django. Для этого необходимо создать RESTful API, который будет обрабатывать запросы от фронтенда и возвращать ответы.
5. Протестировать работу приложения. Необходимо провести тестирование как фронтенд, так и бэкенд-части приложения, чтобы убедиться в их корректной работе.

Такой подход позволяет создавать масштабируемые и гибкие веб-приложения с высокой производительностью.

#### Backend репозиторий проекта

Бэкенд репозиторий проекта расположен на GitHub по адресу - https://github.com/car-service-with-geolocation/backend

Так как моей специализацией является бэкенд разработка на Python это основной репозиторий где я работал.

#### Frontend репозиторий проекта

Фронтенд репозиторий проекта расположен на GitHub по адресу - https://github.com/car-service-with-geolocation/frontend

В репозитории фронтенда размещен код для веб-сайта. Над разработкой фронтальной части приложения работает команда фронтенд-разработчиков. Я использовал этот репозиторий для запуска фронтальной части приложения в контейнере Docker для тестирования интеграции фронтенда и бэкенда через API.

### Технологии и инструменты

- Для работы приложения на сервере используется операционная система Linux. В свою очередь, на рабочей станции я также использую Linux, а конкретно - Fedora Workstation - https://fedoraproject.org/workstation/
- Для размещения готового приложения на сервере, а также для облегчения процесса разработки через создание контейнеров для тестирования фронтенд и бэкенд частей, используется Docker - https://www.docker.com/
- GitHub Actions помогает в развертывании приложения на сервере и организует процесс CI-CD (непрерывная интеграция и доставка) - https://docs.github.com/en/actions
- Django фреймворк для создания веб-приложений - https://www.djangoproject.com/
- Django REST Framework используется для создания API - https://www.django-rest-framework.org/
- С помощью DRF Spectacular создается документация для API - https://drf-spectacular.readthedocs.io/en/latest/
- Poetry служит для управления зависимостями проекта, сборки и управления пакетами - https://python-poetry.org/
- Black используется для форматирования кода на Python - https://pypi.org/project/black/
- Flake8 - это линтер кода на Python, который помогает находить и исправлять ошибки в коде - https://flake8.pycqa.org/en/latest/
- Pyright - это языковой сервер, который предоставляет автодополнение в редакторе и выполняет статический анализ кода - https://github.com/microsoft/pyright
- В качестве редактора кода я использую Neovim - https://neovim.io/

Далее я более подробно разберу использование каждого из этих инструментов и технологий.

## Подготовка окружения для разработки приложения

### Выбор операционной системы для работы приложения

Для операционной системы сервера, на котором будет функционировать приложение, в рамках проекта был выбран Linux. Эта ОС идеально подходит для данной задачи по ряду причин:

- Открытость. Linux является открытым исходным кодом, что даёт пользователям и разработчикам право свободно изучать, модифицировать и распространять систему. Такой подход обеспечивает гибкость и возможность адаптации системы под индивидуальные потребности.
- Бесплатное распространение. Linux предлагается бесплатно, что помогает снизить затраты на внедрение и поддержку сервера.
- Поддержка сообщества. Linux обладает огромным и активным сообществом разработчиков, пользователей и поставщиков, что обеспечивает поддержку и развитие системы.
- Безопасность. В Linux применяется модель безопасности на основе привилегий, которая препятствует несанкционированному доступу к системе. Помимо этого, ядро Linux создано так, чтобы минимизировать уязвимости и эксплойты.
- Надёжность. Linux зарекомендовал себя как стабильная и надёжная операционная система для серверов. Он обеспечивает бесперебойную работу и устойчивость к сбоям, что особенно важно для онлайн-сервисов и веб-приложений.
- Масштабируемость. Linux без труда масштабируется для работы на различных типах серверов, от небольших и недорогих до высокопроизводительных и мощных. Это позволяет использовать Linux для различных задач, включая веб-хостинг, облачные вычисления, базы данных и многое другое.
- Совместимость. Linux поддерживает множество аппаратных и программных компонентов, что делает его совместимым с широким спектром оборудования. Это облегчает процесс развертывания и поддержки сервера.
- Гибкость и настраиваемость. Linux предлагает богатый выбор дистрибутивов и пакетов, что позволяет быстро и легко адаптировать систему для решения конкретных задач.

Один из популярных дистрибутивов Linux - Ubuntu. Именно он был выбран для запуска на сервере.

### Установка Linux для разработки и тестирования приложения

Для разработки и тестирования приложения, предназначенного для платформы Linux, необходимо создать среду разработчика, позволяющую запускать и тестировать приложение непосредственно на целевой платформе. Следовательно, требуется установка Linux в среде разработчика.

Варианты установки Linux в среду разработчика могут быть разными, в зависимости от требований к оборудованию, удобству использования и доступности инструментов. Вот несколько вариантов:

- Использование виртуальной машины (VM): Этот вариант подходит для тех, кто работает на платформе Windows или macOS и хочет протестировать свое приложение на Linux без необходимости установки этой операционной системы на свой компьютер. Виртуальная машина позволяет создать изолированную среду Linux, которую можно запускать на компьютере без влияния на основную операционную систему. Преимущества: простота использования, возможность легкого переключения между разными версиями Linux, совместимость с различными платформами. Недостатки: производительность может быть ниже, чем при использовании реальной установки Linux, некоторые приложения могут не работать должным образом.
- Установка Linux на отдельный жесткий диск или раздел: Этот вариант идеально подходит для тех, кому нужно постоянное и стабильное окружение для разработки на Linux. Преимущества: стабильная среда, возможность использовать все доступные инструменты Linux, высокая производительность. Недостатки: требуется больше времени на первоначальную настройку, нужен отдельный компьютер или отдельный раздел на компьютере.
- Использование облачной платформы: Некоторые облачные платформы, такие как Amazon Web Services (AWS), Microsoft Azure и Google Cloud Platform, предлагают предустановленные образы Linux для разработки и тестирования. Преимущества: возможность быстро развернуть среду Linux в облаке, масштабируемость, доступность инструментов для разработки. Недостатки: возможно, потребуется оплатить подписку на облако, производительность может зависеть от качества соединения с интернетом.
- Использование контейнеров: Это относительно новый подход к развертыванию и управлению приложениями, который позволяет упаковывать приложение и все его зависимости в один легкий и переносимый контейнер. Преимущества: быстрое развертывание и масштабирование, легкое обновление и миграция приложений. Недостатки: некоторые инструменты могут быть сложнее в использовании, чем виртуальные машины.

Я решил установить Linux на жесткий диск, чтобы не только иметь возможность разрабатывать приложение непосредственно для той платформы, на которой оно будет использоваться, но и воспользоваться всеми остальными преимуществами этой системы.

Для установки на свой домашний компьютер я выбрал дистрибутив Fedora Workstation - https://fedoraproject.org/workstation/

### Установка Python при помощи pyenv

Проект использует Python версии 3.9.18, в то время как Fedora 39 включает в себя версию Python 12. Чтобы использовать версию 3.9.18 для проекта, утилита pyenv была установлена. Pyenv обеспечивает удобное переключение между различными версиями Python.

Для установки pyenv перейдем на официальный сайт проекта - https://github.com/pyenv/pyenv

Воспользуемся официальным скриптом для установки pyenv на UNIX системы:

```shell
curl https://pyenv.run | bash
```

> curl - это универсальная утилита командной строки, которая используется для передачи данных с или на сервер. Она поддерживает множество протоколов и может использоваться для выполнения различных задач, таких как загрузка файлов, отправка форм, передача данных в формате HTTP и т.д. Curl также может работать с защищенными соединениями (HTTPS) и поддерживает передачу файлов> большого размера.

Чтобы использовать pyenv, нужно добавить соответствующие конфигурации в файл настроек моей оболочки (shell). Я использую zsh, поэтому файл конфигурации называется `$HOME/.config/zsh/.zshrc`. Нужно добавить в него следующие строки:

```shell
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"
```

Перезапустив оболочку установим python версии 3.9.18 следующей командой:

```shell
pyenv install 3.9.18
```

Создадим в директории проекта файл `.python-version`. Запишем в него версию python для проекта: `3.9.18`.

Теперь при переходе в директорию проекта, текущая версия python будет автоматически переключаться на 3.9.18.

![Демонстрация работы pyenv](./img/pyenv.png)

### Установка Poetry

Poetry - это инструмент управления зависимостями и виртуальной средой для проектов на Python. Он позволяет устанавливать и управлять зависимостями проекта, создавать виртуальную среду и управлять ее настройками.

Poetry заменяет `setup.py`, `requirements.txt`, `setup.cfg`, `MANIFEST.in` и `Pipfile` на простой формат файла проекта `pyproject.toml`.

Чтобы начать использовать Python Poetry, его нужно установить. Это можно сделать разными способами:

- Если виртуальное окружение для проекта уже создано, установить Poetry можно с помощью команды pip: `pip install poetry`.
- Для установки Poetry глобально можно использовать pipx. Этот инструмент изолирует Poetry в виртуальном окружении и позволяет управлять обновлениями и удалениями.
- Пользовательская программа установки Poetry позволяет установить его в новое виртуальное окружение. После установки Poetry может управлять своим окружением.

Я использовал официальный пользовательский установщик Poetry. Для этого я скачал и запустил установочный скрипт с официального сайта:

```shell
curl -sSL https://install.python-poetry.org | python3 -
```

Программа установки создает wrapper для использования Poetry из командной строки. В Linux он обычно размещается в каталоге `$HOME/.local/bin`. Этот каталог содержит исполняемые файлы, привязанные к конкретному пользователю. Чтобы добавить этот каталог в переменную окружения PATH, я добавил следующую строку в файл конфигурации оболочки zsh - `$HOME/.config/zsh/.zshrc`:

```shell
PATH="$PATH:$HOME/.local/bin"
export PATH
```

Это позволит использовать Poetry из любой директории, не указывая полный путь к исполняемому файлу.

### Установка редактора

> В 2023 году мы с прискорбием узнали, что Брам Моленар, создатель редактора Vim, покинул нас в возрасте 62 лет. Эта часть посвящается ему.

Редактор текста это основной инструмент разработчика. Поэтому среди разработчиков популярна тема выбора подходящего текстового редактора.

Популярные варианты включают полнофункциональные интегрированные среды разработки (IntelliJ IDEA, PyCharm, Visual Studio), редакторы с графическим интерфейсом (VSCode, Sublime Text) и редакторы для эмуляторов терминала (Neovim, Vim). Опросив разработчиков на сайте Stack Overflow, мы составили диаграмму популярности текстовых редакторов:

- Полноценные IDE такие как IntelliJ IDEA, PyCharm, Visual Studio.
- Редакторы с графическим интерфейсом такие как VSCode, Sublime Text.
- Редакторы используемые внутри эмулятора терминала такие как Neovim, Vim, Helix.

На диаграмме представлены наиболее популярные текстовые редакторы согласно данным опроса, проведенного на сайте Stack Overflow:

![Stack Overflow survey](./img/sof_2023.png)

В начале карьеры разработчика я узнал о редакторе Vim и его системе горячих клавиш. Мне очень понравилась идея такого подхода к редактированию текста, и я начал осваивать Vim параллельно с программированием. Теперь я не могу представить, как можно редактировать код без горячих клавиш Vim. Я убеждён, что освоение горячих клавиш Vim - одна из лучших инвестиций времени для разработчика.

Я пишу код в [Neovim](https://neovim.io/) - современном форке классического [Vim](https://www.vim.org/), созданного Брамом Моленаром (Эта пояснительная записка, также полностью написана в Neovim).

![Neovim](./img/nvim.png)

Neovim обогатил и улучшил функциональность Vim. Он поддерживает все функции современных редакторов: автодополнение, статический анализ кода, навигацию в проекте, линтинг и форматирование. У Neovim есть преимущества перед другими текстовыми редакторами:

- Визитная карточка Neovim – система горячих клавиш Vim. Это позволяет отказаться от мыши для выделения и перемещения текста, все действия выполняются с помощью клавиатуры, руки остаются на среднем ряду клавиатуры. Хотя в других редакторах тоже можно установить расширения для поддержки клавиш Vim, они все уступают встроенной поддержке Neovim.
- Горячие клавиши Vim работают не только в самом редакторе. Их могут использовать и другие программы. Zsh, Obsidian, Logseq, Emacs, Visual Studio Code и продукты JetBrains поддерживают горячие клавиши Vim. Благодаря этому при переходе на новую среду разработки можно продолжать использовать привычные комбинации клавиш, не тратя время на запоминание новых.
- Neovim как и Vim - консольное приложение, работающее в терминале. Это удобно, потому что можно работать с текстом на удалённом сервере без установки дополнительного ПО. Vim предустановлен на большинстве Unix-подобных систем. Работа в терминале позволяет использовать команды терминала прямо в редакторе: вставлять путь рабочей директории, фильтровать и форматировать текст с помощью grep и sed, выполнять Git-команды.
- В паре с Tmux Neovim становится мощной средой разработки, в которой можно работать над проектами, сохранять и восстанавливать состояние среды между сессиями. Тестирование и отладка кода возможны прямо в терминале, а переключение между редактором и процессом в консоли почти мгновенно.
- Конфигурация Neovim происходит через текстовые файлы с использованием Vim script или Lua. Для новичков это может показаться необычным, ведь они привыкли к графическому интерфейсу. Однако такой метод конфигурации проще и понятнее: пользователь сам решает, какие настройки добавить. Он может постепенно понять, как влияют на него выбранные опции. Изменения в текстовых файлах легко отслеживать через Git. Если изменение настроек не понравилось пользователю, их можно легко откатить к предыдущему состоянию.
- Neovim предлагает множество плагинов и расширений, которые увеличивают его функциональность и превращают его в полноценную среду разработки. Среди них LSP, дополнения, tree-sitter и другие. В зависимости от нужд пользователя Neovim может быть как простым текстовым редактором, так и соперником продуктов Jetbrains по функциональности.

## Создание проекта

### Создание проекта при помощи Poetry

В этом проекте я использую Poetry для управления зависимостями и конфигурации проекта.

Создание проекта Poetry начинается с команды:

```shell
poetry init
```

Я использую `init` вместо `new`, поскольку планирую применять Django - фреймворк с собственной предпочитаемой структурой проекта. Мне не нужна Poetry структура проекта, нам нужен лишь `pyproject.toml`, который создаётся интерактивно через `init`. Полученный файл будет содержать следующее:

```toml
[tool.poetry]
name = "car-service-with-geolocation"
version = "0.1.0"
description = "Веб-приложение для заказа услуг автосервиса с использованием геолокации."
authors = ["Car Service <carservice@carservice.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "3.9.18"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

### Управление зависимостями

Добавление зависимостей в проект происходит через файл `pyproject.toml`, находящийся в корне проекта. В нём хранится информация о зависимостях и другие настройки проекта. Зависимости добавляются двумя способами:

- Командой poetry add: `poetry add some-dependency`.
- Прямым указанием в файле `pyproject.toml`.

Когда мы используем Poetry, мы явно указываем зависимости в файле `pyproject.toml`. Также Poetry позволяет группировать зависимости по группам использования. Основная группа используется для зависимостей, одновременно необходимых в разработке, тестировании и продакшене. Отдельная группа `dev` включает зависимости, нужные только для разработки и тестирования, но лишние в продакшене. Это тестовые фреймворки, линтеры, языковые серверы и подобное.

При сборке приложения и компиляции wheel файлов группа `dev` может быть исключена из финального образа при помощи флага `--without dev`.

В файле pyproject.toml для этого проекта я определил следующие окончательные зависимости:

```toml
[tool.poetry.dependencies]
python = "3.9.18"
djangorestframework = "3.14.0"
Django = "3.2.16"
djoser = "2.1.0"
drf-extra-fields = "3.4.1"
drf-spectacular = "0.26.5"
drf-spectacular-sidecar = "*"
drf-yasg = "1.21.5"
django-filter = "22.1"
django-cors-headers = "3.14.0"
geoip2 = "2.9.0"
gunicorn = "20.1.0"
python-dotenv = "0.21.0"
Pillow = "9.3.0"
pytz = "2023.3.post1"
requests = "2.28.1"


[tool.poetry.group.dev.dependencies]
black = "*"
Flake8-pyproject = "*"
django-extensions = "*"
Werkzeug = "*"
pyOpenSSL = "*"
django-stubs = "*"
djangorestframework-stubs = "*"
```

Зависимости в проекте разделены на две группы: `main` и `dev`. В первую входят обязательные основные зависимости. Во вторую - необязательные, нужные только на этапе разработки.

Описание назначения основных зависимостей в проекте:

**Основные зависимости**

- `python` - Версия Python, на которой будет работать проект
- `djangorestframework` - Фреймворк для создания REST API на Django
- `Django` - Фреймворк для веб-разработки на Python
- `djoser` - Пакет для управления пользователями и авторизацией в Django
- `drf-extra-fields` - Расширение для drf, предоставляющее дополнительные поля для моделей
- `drf-spectacular` - Генератор документации для DRF
- `drf-spectacular-sidecar` - Дополнительный инструмент для drf-spectacular
- `drf-yasg` - Другой генератор документации для DRF
- `django-filter` - Пакет для создания мощных фильтров в Django
- `django-cors-headers` - Пакет для добавления CORS заголовков в ответы Django
- `geoip2` - Библиотека для работы с GeoIP
- `gunicorn` - Веб-сервер WSGI для Python
- `python-dotenv` - Пакет для чтения переменных окружения из .env файла
- `Pillow` - Библиотека для работы с изображениями
- `pytz` - Библиотека для работы с часовыми поясами
- `requests` - Модуль для отправки HTTP запросов

**Необязательные зависимости для разработки**

- `black` - Форматер кода
- `Flake8-pyproject` - Статический анализатор кода
- `django-extensions` - Расширения для Django
- `Werkzeug` - WSGI веб-сервер и вспомогательные модули
- `pyOpenSSL` - Модуль для работы с SSL
- `django-stubs` - Stub-файлы для Django
- `djangorestframework-stubs` - Stub-файлы для drf

> Stub-файлы в Python используются для упрощения процесса разработки и отладки кода. Они представляют собой псевдокод для отсутствующих или недоступных модулей и классов, что позволяет IDE (интегрированной среде разработки) предоставлять контекстную информацию и подсказки, даже если реальный код ещё не написан или не доступен.
>
> Stub-файлы особенно полезны при использовании фреймворков, таких как Django, где многие части приложения могут быть реализованы позже или зависеть от внешних библиотек. Они помогают поддерживать непрерывность разработки и ускоряют процесс написания кода, предоставляя базовую структуру и информацию о типах данных и методах, которые должны быть реализованы.
>
> Stub-файлы также могут использоваться для тестирования кода до полной реализации зависимостей, что позволяет разработчикам быстрее находить и исправлять ошибки.

### Дополнительных инструменты для редактирования кода

#### Языковой сервер и статический анализатор кода Pyright

Статические анализаторы кода и языковые серверы – неотъемлемые инструменты современного программиста. Анализаторы, как CLI-инструменты, парсят код и находят ошибки синтаксиса, типов и логики. Отчеты с рекомендациями по исправлению предоставляются разработчику. Language Server Protocol (LSP), предложенный Microsoft, стандартизировал взаимодействие между анализаторами и редакторами кода.

Языковые серверы обрабатывают код и статически анализируют его. Редакторы кода, инструменты командной строки и другие клиенты могут взаимодействовать с ними через LSP. Большинство современных редакторов поддерживают интеграцию с языковыми серверами, включая популярный Pyright для Python.

В данном проекте Pyright добавлен как зависимость разработки в `pyproject.toml`. Это позволяет использовать его из командной строки и служит документацией для других разработчиков. Neovim, поддерживающий LSP, использует Pyright для предоставления автодополнения, подсветки ошибок и статического анализа в реальном времени.

Настройки статического анализатора кода задаются в `pyproject.toml` в разделе `[tool.pyright]`.

```toml
[tool.pyright]
include = []
exclude = [".pytest_cache",
    "**/__pycache__",
]
pythonVersion = "3.9.18"
typeCheckingMode = "standard"
```

В `pyproject.toml` настраивается работа статического анализатора кода Pyright.

- `include` - файлы и директории, которые явно включаются в область анализа.
- `exclude` - файлы и директории, которые исключаются из анализа для ускорения работы инструмента.
- `pythonVersion` - версия Python, от которой зависит работа Pyright. В зависимости от версии анализатор указывает на устаревшие или ещё не используемые в данной версии синтаксические конструкции.
- `typeCheckingMode` - уровень строгости, с которым Pyright подходит к анализу кода.

#### Линтер Flake8

Линтер - программа, проверяющая код на соответствие правилам форматирования. Она следит за отступами, количеством пустых строк и другими параметрами. Среди популярных линтеров для Python - flake8, pylint, ruff. В данном проекте используется flake8, который проверяет код на соответствие стандарту PEP8.

Flake8 можно установить локально в проект, глобально на систему или внутри редактора кода. В данном случае он добавлен в `pyproject.toml` как зависимость разработки, что позволяет использовать его из командной строки и служит документацией для других разработчиков.

Настройки линтера кода также задаются в `pyproject.toml` в разделе `[tool.flake8]`.

```toml
[tool.flake8]
max-line-length = 88
extend-ignore = ["E203", "I001", "I005", "R504"]
exclude = [
    ".git",
    "__pycache__",
    "env",
    "migrations",
    "settings.py",
    "venv",
    "management"
]
max-complexity = 10
```

В `pyproject.toml` настраивается линтер flake8.

- `max-line-length` - максимальная длина строки кода.
- `extend-ignore` - список кодов ошибок, которые будут игнорироваться при проверке кода.
- `exclude` - глобальные паттерны, которые будут исключены из проверок.
- `max-complexity` - максимально допустимая сложность кода по шкале McCabe.

> Сложность кода по шкале McCabe - это мера сложности алгоритма, основанная на количестве независимых путей через него. Она помогает оценить сложность понимания и тестирования кода. Чем ниже значение сложности, тем проще и понятнее код.

#### Форматер Black

Форматер кода автоматически редактирует код в соответствии с выбранными правилами. Среди популярных форматеров для Python - Black и Ruff. В данном проекте используется Black. Он позволяет форматировать код согласно заданным правилам или выбранным по умолчанию.

Black называют _optionated_, потому что некоторые его правила не соответствуют стандартам PEP8. Например, PEP8 определяет максимальную длину строки в 79 символов, а Black по умолчанию устанавливает 88 символов.

Black можно установить локально в проект, глобально на систему или внутри редактора кода. В данном случае он добавлен в `pyproject.toml` как зависимость разработки, что позволяет использовать его из командной строки и служит документацией для других разработчиков.

Настройки форматера кода задаются в `pyproject.toml` в разделе `[tool.black]`.

```toml
[tool.black]
line-length = 88
```

- `line-length` - В `pyproject.toml` для Black устанавливается максимальная длина строки в 88 символов. Остальные правила используются по умолчанию.

### Установка зависимостей в проект

Для установки зависимостей в проект с помощью Poetry выполняется команда:

```shell
poetry install
```

Если нужно установить только зависимости проекта, без пакетов, используется флаг --no-root:

```shell
poetry install --no-root.
```

Если мы никогда раньше не выполняли эту команду, а также отсутствует файл `poetry.lock`, Poetry просто разрешит все зависимости, перечисленные в файле `pyproject.toml`, и загрузит последнюю версию их файлов.

После завершения установки Poetry записывает все пакеты и их точные версии, которые были загружены, в файл `poetry.lock`, фиксируя проект до этих конкретных версий. Нужно зафиксировать файл `poetry.lock` в репозитории проекта, чтобы все люди, работающие над проектом, имели одинаковые версии зависимостей.

Если при запуске `poetry install` уже есть файл `poetry.lock`, а также файл `pyproject.toml`, это означает, что либо мы выполнили команду install раньше, либо кто-то другой в проекте выполнил команду install и зафиксировал файл `poetry.lock` в проекте.

Запуск install при наличии файла `poetry.lock` разрешает и устанавливает все зависимости, которые мы перечислили в `pyproject.toml`, но Poetry использует точные версии, перечисленные в `poetry.lock`, чтобы гарантировать, что версии пакетов будут согласованы для всех, кто работает над нашим проектом. В результате у наш будут все зависимости, запрошенные в файле `pyproject.toml`, но не все они могут быть в самых последних доступных версиях (некоторые зависимости, перечисленные в файле poetry.lock, могли выпустить более новые версии с момента создания файла). Это сделано специально, чтобы наш проект не сломался из-за неожиданных изменений в зависимостях.

Разработчики приложений фиксируют `poetry.lock`, чтобы получить более воспроизводимые сборки.

Коммит этого файла в систему контроля версий важен, потому что он заставит всех, кто устанавливает проект, использовать точно такие же версии зависимостей, которые используем мы. Наш CI-сервер, рабочие машины, другие разработчики в нашей команде - все работают на одних и тех же зависимостях, что снижает вероятность возникновения ошибок, затрагивающих только некоторые части развертываний. Даже если мы разрабатываем в одиночку, мы можем быть уверены, что установленные зависимости все еще работают, даже если с тех пор наши зависимости выпустили множество новых версий.

### Запуск виртуального окружения Poetry

Poetry по умолчанию создает виртуальное окружение в `{cache-dir}/virtualenvs`. Можно изменить `cache-dir`, отредактировав конфигурацию Poetry, или использовать `virtualenvs.in-project` для создания окружения в каталоге проекта.

Чтобы запустить скрипт в этом окружении, используем `poetry run python your_script.py`. Для инструментов командной строки, таких как pytest или black, используем `poetry run pytest`.

Самый простой способ активировать виртуальное окружение - создать вложенную оболочку с помощью `poetry shell`. Чтобы деактивировать окружение и выйти из оболочки, введем `exit`. Для деактивации, не выходя из оболочки, используем `deactivate`.

## Работа над проектом

### Выбор Django в качестве фреймворка для проекта

Django — один из самых популярных фреймворков на Python. Он предлагает структуру MVT (Model View Template) для приложений. Благодаря стандартизации Django разработчики могут быстро создавать приложения на фреймворке, не тратя время на изобретение собственных решений. Это ускоряет процесс разработки.

### Структура проекта Django

Когда мы используем Django, нам придется позаботиться о создании проекта Django и его начальной настройке. Нам нужно будет автоматически сгенерировать структуру и файлы проекта Django: набор настроек для экземпляра Django, включая конфигурацию базы данных, специфические для Django опции и настройки для приложения.

Чтобы сделать это, В командной строке перейдем в каталог, где будет храниться наш код, и выполним следующую команду:

```shell
django-admin startproject car_service
```

Начальная структура будет выглядеть так:

```
car_service/
    manage.py
    car_service/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
```

Эти файлы:

- Внешний корневой каталог `car_service/`: это контейнер для нашего проекта.
- `manage.py`: Утилита командной строки, которая позволяет вам взаимодействовать с проектом Django различными способами.
- Внутренний каталог `mysite/`: это собственно Python-пакет для проекта.
- `mysite/__init__.py`: Пустой файл, который сообщает Python, что эта директория должна считаться пакетом Python.
- `mysite/settings.py`: Настройки/конфигурация для этого проекта Django.
- `mysite/urls.py`: Декларации URL для этого Django-проекта.
- `mysite/asgi.py`: Точка входа для ASGI-совместимых веб-серверов для обслуживания проекта.
- `mysite/wsgi.py`: Точка входа для WSGI-совместимых веб-серверов для обслуживания проекта.

### Приложения Django

Приложение в Django, состоит из пакета Python, который следует определенным соглашениям. Django поставляется с утилитой, которая автоматически генерирует базовую структуру каталогов приложения.

В чем разница между проектом и приложением? Приложение - это веб-приложение, которое что-то делает - например, система блогов, база данных публичных записей или небольшое приложение для опросов. Проект - это набор конфигураций и приложений для определенного веб-сайта. Проект может содержать несколько приложений. Приложение может находиться в нескольких проектах.

Чтобы создать приложение, выполним команду:

```shell
python manage.py startapp autoservice
```

Создаст создает новое приложение с именем `autoservice` в текущем проекте.

1. Создается новая директория с именем `autoservice` внутри приложения Django.
2. В этой директории создаются файлы и папки, которые являются стандартными для приложения Django:
   - `models.py`: содержит определения моделей данных.
   - `views.py`: содержит определения представлений.
   - `admin.py`: содержит определения админ-панели для моделей.
   - `tests.py`: содержит начальный файл тестов для приложения.
   - `migrations`: папка, которая будет использоваться для управления миграциями базы данных.
   - `__init__.py`: пустой файл, который делает директорию распознаваемой как пакет Python.
3. Если в проекте уже есть модели данных, команда также создает файл начальной миграции, который будет содержать информацию о структуре базы данных, необходимую для создания приложения.

При разработке приложения на Django стоит придерживаться современного дизайна, например «Domain Driven Development» или «Hexagonal Architecture». Этому способствует разделение проекта на приложения, каждое из которых представляет отдельную доменную область. Такой подход облегчает рефакторинг монолитного проекта и его преобразование в систему сервисов и микросервисов в соответствии с подходом к разработке облачных приложений.

> Domain-driven design (DDD) — это методология разработки программного обеспечения, которая применяется при создании крупных программных систем. Она помогает разработчикам лучше понять доменную область, которую они разрабатывают, и создать код, который лучше соответствует потребностям пользователей. В основе DDD лежит идея о том, что разработчики должны тесно сотрудничать с экспертами в предметной области, чтобы лучше понять их потребности и создать программное обеспечение, которое будет удовлетворять этим потребностям. Это достигается за счет использования UML-диаграмм, моделей бизнес-процессов и других инструментов для моделирования доменной области.

> Hexagonal Architecture, также известная как Ports and Adapters, — это архитектурный шаблон, который помогает разработчикам создавать более гибкие и легко поддерживаемые программные системы. Основная идея Hexagonal Architecture заключается в том, чтобы изолировать бизнес-логику от внешних зависимостей, таких как базы данных, веб-серверы, API и т.д. Это позволяет разработчикам легко изменять и расширять функциональность приложения, не затрагивая его ядро.

В текущем проекте гибкий дизайн приложения и постоянный рефакторинг кода подкачали. Мы, новички в программировании, спроектировали связанные приложения, похожие на таблицы в базе данных.

В каждом приложении есть модели, относящиеся к похожим понятиям. Например, модель автосервисов, модель данных о геолокации автосервисов и модель данных отзывов об автосервисе.

Финальная структура проекта выглядит следующим образом:

```
backend
├── api
│   ├── apps.py
│   ├── __init__.py
│   ├── urls.py
│   └── v1
│       ├── autoservice
│       │   ├── filters.py
│       │   ├── __init__.py
│       │   ├── permissions.py
│       │   ├── serializers.py
│       │   ├── tests
│       │   │   ├── __init__.py
│       │   │   └── test_company_owner_viewset.py
│       │   ├── urls.py
│       │   └── views.py
│       ├── core
│       │   ├── __init__.py
│       │   ├── urls.py
│       │   └── views.py
│       ├── __init__.py
│       ├── order
│       │   ├── __init__.py
│       │   ├── permissions.py
│       │   ├── serializers.py
│       │   ├── tests
│       │   │   ├── __init__.py
│       │   │   ├── setup_test_db.py
│       │   │   ├── test_current_user_view.py
│       │   │   └── test_order_view.py
│       │   ├── urls.py
│       │   ├── utils.py
│       │   └── views.py
│       ├── urls.py
│       └── users
│           ├── exceptions.py
│           ├── __init__.py
│           ├── serializers.py
│           ├── tests
│           │   ├── __init__.py
│           │   ├── test_company_owner_post.py
│           │   └── test_current_user_patch.py
│           ├── urls.py
│           └── views.py
├── autoservice
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── __init__.py
│   ├── models.py
├── car_service
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── core
│   ├── apps.py
│   ├── __init__.py
│   ├── management
│   │   ├── commands
│   │   │   ├── import_autoservice.py
│   │   │   ├── import_city.py
│   │   │   ├── import_user.py
│   │   │   ├── __init__.py
│   │   ├── __init__.py
│   ├── utils.py
│   └── validators.py
├── docker-compose.dev.yml
├── docker-compose.prod.yml
├── Dockerfile
├── isort.cfg
├── manage.py
├── order
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── __init__.py
│   ├── models.py
├── poetry.lock
├── pyproject.toml
├── README.md
├── setup.cfg
└── users
    ├── admin.py
    ├── apps.py
    ├── backends.py
    ├── __init__.py
    ├── migrations
    │   ├── __init__.py
    ├── models.py
```

1. `manage.py`: Этот файл используется для управления проектом Django. Он содержит команды для запуска сервера, создания приложений, миграции базы данных и т.д.
2. `settings.py`: Файл настроек проекта. Здесь определяются настройки приложения, такие как подключение к базе данных, настройки сайта, пути к статическим файлам и т.д.
3. `urls.py`: Файлы, которые содержат маршрутизацию приложения. Здесь определяются URL-адреса, которые соответствуют определенным view функциям.
4. `serializers.py`: файлы которые используются для создания сериализаторов. Сериализаторы - это класс, который позволяет преобразовывать объекты модели в формат, который может быть отправлен через HTTP (например, в JSON), и обратно.
5. `app_name/`: Папка для каждого приложения в проекте. Внутри этой папки обычно находятся файлы `models.py`, `views.py`, `urls.py`, `admin.py`, `tests.py` и другие, которые содержат модели данных, представления, админ-панель и тесты соответственно.
6. `static/`: Папка для статических файлов, таких как CSS, JavaScript и изображения.
7. `migrations/`: Папки, которые содержат файлы миграции базы данных. Каждый файл миграции представляет собой изменение схемы базы данных.
8. `README.md`: Файл, который содержит описание проекта и инструкции по его использованию.
9. `Dockerfile`: Файл Dockerfile, если проект использует Docker для развертывания.
10. `.gitignore`: Файл, который содержит список файлов и директорий, которые следует игнорировать при контроле версий с помощью Git.
11. `docs/`: Папка для документации проекта.
12. `tests/`: Папки для тестов проекта.
13. `views.py`: - Файл который содержит классы или функции, которые обрабатывают HTTP-запросы и отвечают на них. Эти функции или классы называются представлениями (views) и являются основным способом обработки запросов в Django.
14. `models.py`: Файл который содержит определения моделей данных, которые представляют структуру данных в приложении Django. Модели Django определяют структуру таблиц в базе данных и предоставляют механизмы для работы с этими данными, такие как создание, чтение, обновление и удаление (CRUD).
15. `permissions.py`: Файл который используется для определения разрешений (permissions) для пользователей или групп пользователей. В Django разрешения используются для контроля доступа к различным частям приложения, таким как просмотр, редактирование или удаление данных.
16. `admin.py`: Файл который используется для определения административных страниц для моделей данных, определенных в `models.py`. С помощью административного интерфейса Django разработчики и администраторы могут управлять данными в приложении, такими как создание, просмотр, редактирование и удаление записей.

#### Структура Django и pyproject.toml

Управление зависимостями проекта осуществляется через Poetry. Эта система позволяет устанавливать только зависимости без самого проекта, используя команду `poetry install --no-root`. Однако, при сборке проекта и его развертывании на продакшн-сервере, необходимо установить и сам проект.

В файле `pyproject.toml` нужно указать все пакеты приложения Django, которые будут установлены в проект. Поскольку корень проекта Django совпадает с корнем проекта Poetry (там, где находится `pyproject.toml`), следует явно указать все Python-пакеты в корне проекта.

```toml
[tool.poetry]
name = "car-service-with-geolocation"
version = "0.1.0"
description = "Веб-приложение для заказа услуг автосервиса с использованием геолокации."
authors = ["Car Service <carservice@carservice.com>"]
readme = "README.md"
packages = [
    { include = "api" },
    { include = "autoservice" },
    { include = "car_service" },
    { include = "core" },
    { include = "order" },
    { include = "users" },
]
```

В поле `packages` перечислены все пакеты, которые нужно включить, с использованием синтаксиса `{ include = "<Название пакета>" }`. Эти пакеты устанавливаются в окружение при сборке проекта.

### Структура данных проекта

#### Структура

Данные которыми будет оперировать приложение представляют собой следующую структуру:

![ERD диаграмма проекта](./img/car_service_erd.png)

#### Базовые модели проекта

##### User (CustomUser)

Модель User (CustomUser) содержит поля:

- `email` — электронная почта пользователя;
- `name` — имя пользователя;
- `phone_number` — телефон пользователя;
- `date_joined` — дата регистрации пользователя.

Model CustomUser расширяет Модель кастомного пользователя и использует библиотеку Djoser для работы с пользователями. Предусмотрена авторизация по электронной почте.

REST-аутентификация в Django с помощью djoser. Djoser предоставляет набор представлений для Django Rest Framework, обрабатывающих основные действия: регистрацию, вход, выход, сброс пароля и активацию аккаунта. Работает с пользовательской моделью пользователя.

##### Company

Модель `Company` содержит поля:

- `title` — название компании;
- `description` — описание компании;
- `logo` — путь к логотипу;
- `legal_address` — юридический адрес;
- `taxpayer_id` — ИНН;
- `owner` — пользователь владельца.

Модель хранит информацию о компании, владеющей сетью автосервисов. Планируется добавить веб-страницу кабинета владельца компании для управления.

##### Autoservice

Модель `Autoservice` содержит поля:

- `company` — компания, к которой принадлежит автосервис;
- `address` — фактический адрес;
- `geolocation` — данные геолокации;
- `city` — город местонахождения;
- `working_time` — рабочие часы;
- `phone_number` — телефон для связи;
- `email` — электронная почта для связи;
- `site` — сайт автосервиса;
- `job` — выполняемые виды работ;
- `car_service` — обслуживаемые марки автомобилей.

Модель хранит информацию об автосервисе: контактные данные, адрес и услуги.

##### Geolocation

Модель `Geolocation` содержит поля:

- `latitude` — широта точки геолокации;
- `longtitude` — долгота точки геолокации.

Модель хранит информацию о точке геолокации автосервиса: долгота и широта. Точка геолокации используется для определения положения автосервиса на картах, например, Yandex Maps.

##### City

Модель `City` содержит поля:

- `rus_name` — название города на русском языке;
- `geolocation` — данные геолокации города.

Модель хранит информацию о городе, где расположен автосервис: название города и его геолокацию. Используется для фильтрации автосервисов по городу, в котором находится пользователь.

##### GeolocationCity

Модель `GeolocationCity` содержит поля:

- `latitude` — широта точки геолокации;
- `longtitude` — долгота точки геолокации.

Модель хранит информацию о точке геолокации города: долгота и широта. Используется для определения города по данным геолокации пользователя.

##### WorkingTime

Модель `WorkingTime` содержит поля:

- `day` — день недели;
- `time` — часы работы в формате `ЧЧ:ММ - ЧЧ:ММ`.

Модель позволяет задать расписание работы автосервиса на разные дни недели.

##### Transport

Модель `Transport` содержит поля:

- `brand` — марка автомобиля.

Модель используется для фильтрации поиска и указания марок автомобилей, с которыми работает автосервис.

##### Jobs

Модель `Jobs` содержит поля:

- `title` - наименование типа работ

Модель хранит список работ, выполняемых автосервисами. Это позволяет фильтровать автосервисы по типам выполняемых ими работ.

##### Order

Модель `Order` содержит поля:

- `owner` — заказчик работ;
- `car` — марка и модель автомобиля заказчика;
- `info` — информация о заказчике;
- `task` — описание проблемы;
- `jobs` — работы, которые необходимо выполнить;
- `pub_date` — дата создания заказа;
- `status` — статус заказа;
- `autoservice` — автосервис, куда направлен заказ;
- `phone_number` — телефон для связи с заказчиком.

Модель хранит заказы на ремонт, которые пользователи оставляют автосервисам. Заказ содержит информацию о заказчике и автомобиле, проблеме и необходимых работах. Заказы имеют статус выполнения.

##### OrderImages

Модель `OrderImages` содержит поля:

- `file` — путь к файлу изображения;
- `upload_date` — дата загрузки изображения;
- `order` — заказ, к которому относится изображение.

Модель хранит изображения, которые пользователь загружает к заказу при его создании. Включает путь к изображению на сервере, дату загрузки и связанный с ним заказ.

##### Feedback

Модель `Feedback` содержит поля:

- `author` — пользователь, автор отзыва;
- `autoservice` — автосервис, о котором оставлен отзыв;
- `text` — текст отзыва;
- `score` — оценка, выставленная пользователем автосервису;
- `pub_date` — дата публикации отзыва.

Модель отзывов об автосервисе, которые могут оставлять пользователи.

### API проекта.

#### Что такое REST API

REST API (REpresentational State Transfer) — это стиль архитектуры API, который облегчает взаимодействие между различными компонентами программного обеспечения. REST API основан на концепции клиент-серверного взаимодействия, где клиент (например, веб-браузер или мобильное приложение) отправляет запросы на сервер, а сервер возвращает ответы в формате, который клиент может понять.

Основные принципы работы REST API:

1. Использование HTTP-методов (GET, POST, PUT, DELETE) для различных операций.
2. Использование стандартных HTTP-кодов состояния для обозначения успешности или неудачи запроса.
3. Использование идентификаторов ресурсов для адресации объектов в системе.
4. Возможность кэширования ответов для улучшения производительности.
5. Использование медиа-типов для определения формата данных, передаваемых между клиентом и сервером.

REST API широко используется в веб-разработке благодаря своей простоте, гибкости и масштабируемости. Он позволяет создавать сложные системы с минимальными затратами на разработку и поддержку, а также обеспечивает высокую степень безопасности благодаря стандартизации протокола HTTP.

#### Описание API проекта

Проект представляет собой API-сервер, поэтому его структура состоит из нескольких Django приложений и отдельного приложения `api`. В приложении API находятся все файлы `urls.py`, `serializers.py`, `views.py` относящиеся к конечным точкам API. Такая структура позволяет мне быстро создавать новые версии API, но при этом она может усложнять проект из-за большого количества директорий.

> API-сервер - это программное обеспечение, которое предоставляет доступ к сервисам или данным через специальный интерфейс, называемый API (Application Programming Interface). API позволяет различным приложениям и сервисам обмениваться информацией и взаимодействовать друг с другом.

> Конечные точки (endpoints) API - это уникальные URL-адреса, которые определяют конкретные функции или ресурсы, доступные через API. Они используются для отправки запросов к API и получения ответов от него. Конечные точки обычно определяются в файле маршрутизации API (например, `urls.py` в Django) и соответствуют определенным методам HTTP (например, GET, POST, PUT, DELETE).

Структура директории `api/`:

```
api
├── apps.py
├── __init__.py
├── urls.py
└── v1
    ├── autoservice
    │   ├── filters.py
    │   ├── __init__.py
    │   ├── permissions.py
    │   ├── serializers.py
    │   ├── tests
    │   │   ├── __init__.py
    │   │   └── test_company_owner_viewset.py
    │   ├── urls.py
    │   └── views.py
    ├── core
    │   ├── __init__.py
    │   ├── urls.py
    │   └── views.py
    ├── __init__.py
    ├── order
    │   ├── __init__.py
    │   ├── permissions.py
    │   ├── serializers.py
    │   ├── tests
    │   │   ├── __init__.py
    │   │   ├── setup_test_db.py
    │   │   ├── test_current_user_view.py
    │   │   └── test_order_view.py
    │   ├── urls.py
    │   ├── utils.py
    │   └── views.py
    ├── urls.py
    └── users
        ├── exceptions.py
        ├── __init__.py
        ├── serializers.py
        ├── tests
        │   ├── __init__.py
        │   ├── test_company_owner_post.py
        │   └── test_current_user_patch.py
        ├── urls.py
        └── views.py
```

Файлы `urls.py`, `serializers.py`, `views.py` размещены в директории `api/v1/`. Такое расположение файлов позволяет контролировать изменения и упрощает развитие API в будущем. Если потребуется серьёзно изменить функционал API, можно создать отдельную директорию `v2` и разрабатывать новую версию API, не опасаясь за работоспособность текущей версии API, которая используется в продакшене.

Структура директории `api/v1/` повторяет структуру приложений Django, содержит директории `autoservice`, `orders`, `users`, `autoservice`. В основных директориях размещены `tests/`, где хранятся тесты представлений, относящихся к конкретной области API. В `core/` находятся представления, которые нельзя отнести к определенному приложению, а также вспомогательные функции, такие как валидаторы данных.

### Фреймворк аутентификации и работа с пользователем

Django поставляется с системой аутентификации пользователей. Она работает с учетными записями пользователей, группами, разрешениями и пользовательскими сессиями на основе cookie. В этом разделе документации рассказывается о том, как работает стандартная реализация из коробки, а также о том, как расширить и настроить ее под нужды вашего проекта.
Обзор

Система аутентификации Django работает как с аутентификацией, так и с авторизацией. Вкратце, аутентификация проверяет, является ли пользователь тем, за кого он себя выдает, а авторизация определяет, что разрешено делать аутентифицированному пользователю. Здесь термин аутентификация используется для обозначения обеих задач.

Система аутентификации состоит из:

- Пользователи .
- Разрешения: Двоичные (да/нет) флаги, обозначающие, может ли пользователь выполнять определенную задачу.
- Группы: Общий способ применения меток и разрешений к нескольким пользователям.
- Настраиваемая система хеширования паролей
- Формы и инструменты просмотра для регистрации пользователей или ограничения содержимого.
- Подключаемая бэкэнд-система

Система аутентификации в Django стремится быть очень общей и не предоставляет некоторых возможностей, обычно встречающихся в веб-системах аутентификации. Решения некоторых из этих общих проблем были реализованы в сторонних пакетах:

- Проверка надежности пароля
- Ограничение попыток входа в систему
- Аутентификация от третьих лиц (например, OAuth)
- Разрешения на уровне объектов

Для упрощения работы с представлениями рутингами и системой аутентификации пользователя в проекте используется бибилиотека Djoser.

REST-реализация системы аутентификации Django. Библиотека djoser предоставляет набор представлений Django Rest Framework для обработки основных действий, таких как регистрация, вход, выход, сброс пароля и активация аккаунта. Она работает с пользовательской моделью пользователя.

Вместо того чтобы повторно использовать код Django (например, PasswordResetForm), мы переделали несколько вещей, чтобы они лучше вписывались в архитектуру Single Page App.

### Приложения проекта

Теперь, когда ваше окружение - "проект" - создано, вы можете приступать к работе.

Каждое приложение, которое вы пишете в Django, состоит из пакета Python, который следует определенному соглашению. Django поставляется с утилитой, которая автоматически генерирует базовую структуру каталогов приложения, так что вы можете сосредоточиться на написании кода, а не на создании каталогов.

Проекты против приложений

В чем разница между проектом и приложением? Приложение - это веб-приложение, которое что-то делает - например, система блогов, база данных публичных записей или небольшое приложение для опросов. Проект - это набор конфигураций и приложений для определенного веб-сайта. Проект может содержать несколько приложений. Приложение может находиться в нескольких проектах.

Ваши приложения могут находиться в любом месте на пути Python. В этом уроке мы создадим наше приложение poll в той же директории, что и файл manage.py, чтобы его можно было импортировать как собственный модуль верхнего уровня, а не как подмодуль mysite.

Для проекта создано несколько приложений которые определяют его структуру:

- autoservice - приложение для работы с данными автосервиса
- users - приложение для работы с данными пользователей
- orders - приложение для работы с заявками пользователей автосервисам

## Тестирование и отладка проекта

### Тестовый фреймворк django

Автоматизированное тестирование - чрезвычайно полезный инструмент для устранения ошибок для современного веб-разработчика. Вы можете использовать набор тестов - набор тестов - для решения или предотвращения ряда проблем:

При написании нового кода вы можете использовать тесты для проверки того, что ваш код работает так, как ожидалось.
При рефакторинге или модификации старого кода вы можете использовать тесты, чтобы убедиться, что внесенные изменения не повлияли на поведение приложения неожиданным образом.

Тестирование веб-приложения - сложная задача, поскольку веб-приложение состоит из нескольких слоев логики - от обработки запросов на уровне HTTP, проверки и обработки форм до рендеринга шаблонов. С помощью фреймворка Django для тестирования и различных утилит вы можете имитировать запросы, вставлять тестовые данные, проверять результаты работы приложения и вообще проверять, что ваш код делает то, что должен делать.

Предпочтительным способом написания тестов в Django является использование модуля unittest, встроенного в стандартную библиотеку Python.

### Тестирование API

#### Docker контейнер для тестирования API

Для удобства тестирования и ускорения итерации в процессе разработки приложение запускается в Docker контейнере.

##### Описание

Этот контейнер - это независимый сервер, который использует Werkzeug и Django для функционирования. На этом сервере работает версия приложения backend, которая размещена в локальной директории компьютера. Любые изменения в исходном коде непосредственно влияют на функционирование контейнера.

##### Подготовка среды для запуска контейнера

Чтобы начать работу с контейнером необходимо:

Клонировать репозиторий [backend](https://github.com/car-service-with-geolocation/backend) в локальную директорию:

Используя https протокол:

```shell
git clone https://github.com/car-service-with-geolocation/backend.git
```

Либо используя SSH протокол:

```shell
git clone git@github.com:car-service-with-geolocation/backend.git
```

###### Установить Docker на локальный компьютер

Инструкции по установке Docker в вашей операционной системе можно найти на [официальном веб сайте Docker](https://docs.docker.com/get-docker/).

###### Создать файл .env

Чтобы установить системные переменные, вы должны скопировать файл `.env.template` в файл `.env`.

В Linux и MacOS:

```shell
cp .env.template .env
```

В Windows:

```powershell
Copy-Item -Path <Путь к .env.template> -Destination <Путь к .env>
```

##### Сборка и первый запуск контейнера

Для того чтобы собрать и запустить контейнер выполните следующую команду docker-compose:

```shell
docker compose -f docker-compose.dev.yml up -d
```

Вы также можете запустить Docker-compose через приложение Docker Desktop или используя расширение Docker для VS Code.

Будет создан и запущен контейнер с именем `car-dev-server`. Сервис будет назван `dev-server`.

Сервер будет работать по ссылке: `https://127.0.0.1:8000`.

##### Работа с контейнером

###### Миграция базы данных

Для миграции базы данных выполните команды:

```shell
docker exec -i car-dev-server python manage.py migrate
docker exec -i car-dev-server python manage.py import_city
docker exec -i car-dev-server python manage.py import_autoservice
docker exec -i car-dev-server python manage.py import_user
```

###### Создание вашего пользователя

Чтобы создать суперпользователя для проверки подлинности и использования Django Admin, вам нужно выполнить следующую команду:

```shell
docker exec -i car-dev-server python manage.py createsuperuser
```

Для пользователя необходимо получить токен аутентификации и добавить его в заголовок вашего запроса в Postman. Для получения токена выполните следующую команду:

```shell
docker exec -i car-dev-server python manage.py drf_create_token <Почта созданного вами ранее пользователя>
```

##### Запуск, перезапуск и остановка контейнера

Для запуска, перезапуска и остановки контейнера рекомендуется использовать команды Docker Compose:

**Запуск:**

```shell
docker compose -f docker-compose.dev.yml start
```

**Перезапуск:**

```shell
docker compose -f docker-compose.dev.yml restart
```

**Остановка:**

```shell
docker compose -f docker-compose.dev.yml stop
```

#### Использование Postman для тестирования API

Для тестирования API проекта я использовал приложение Postman.

## Развертывание проекта на сервере

### Docker контейнер для запуска приложения на сервере

### Запуск приложения на сервере

## Результаты работы над проектом
